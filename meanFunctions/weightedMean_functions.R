# Get vector for which zero weights for tableList object
getNnull <- function(x) {
	if(class(x)!="tableList") {
		stop('x is not a tableList object')
	}
	n0 <- sapply(x["structure",], "[[", "cellN")
	n0 <- which(n0==0)
	return(n0)
}

# print dataset and get the number of subjects per column
readN <- function(x, n0, startCol, name) {
	cat(name)
	print(x, quote = FALSE)
	k <- dim(x)[2] - 1
	n <- readintegerline(x = "What are the number of subject for each column? (integers, comma separated)   ")
	if (length(n) != k) n <- rep(0, k)
	names(n) <- colnames(x)[-k]
	return(list(set = n0, startCol = startCol, nval = n))
}

# Find missing subject numbers and prompt for input
fillNnull <- function(x) {
	if(class(x)!="tableList") {
		stop('x is not a tableList object')
	}
	n0 <- getNnull(x)
	start <- sapply(x["structure",], "[[", "startCol")[n0]
	x <- x["data",][n0]
	setNames <- names(x)
	n <- mapply(x = x, n0 = n0, startCol = start, 
		name = setNames, readN, )
	class(n) <- "fillN"
	return(n)
}

# Convert n to weights, i = which pattern to choose
# dimx is the number of dimensions: it will be 1 when there is only 
# one column with data in the table
# name is the name of table/filename
# fillN is an object generated by fillNull()
ntoweights <- function(x, fillN = NULL, dimx = 2, name = "", i = 1,
		returnN = FALSE) {
	if(dimx == 1) {
		n <- x[i]
		if(is.na(n)) n <- x[i+2]
		l <- length(x[i])
	} else { 
		n <- x[i, ]
		if(any(is.na(n))) n <- x[i+2,]
		l <- length(x[i,])
	}
	if (sum(n) == 0) {
		if (!is.null(fillN)) {
			if(class(fillN)!= "fillN") {
				stop('fillN must be an object generated by fillNnull()')
			}
			if(name == "") stop('name cannot be empty when using fillN')
			n <- fillN[,name]$nval
		} else {
			cat(name)
			cat("\nNumber of subjects missing\n")
			n <- readintegerline(x = "What are the number of subject for each column? (integers, comma separated)\n")
			if(length(n) != l) {
				cat("Number of columns does not match the table\n")
				return(ntoweights(x, i))
			}
		}
	}
	# Do not return the probability (weight) but the total N
	if(returnN == TRUE) {
		return(n)
	} else if (returnN == "sum") {
		return(sum(n))
	} else {
		return(prop.table(n))
	}
}

# Weighted Means per dimension (typically per variable)
weightedMarginMeans <- function(x, w, MARGIN = 1) {
	y <- apply(x, MARGIN, weighted.mean, w)
	return(y)
}

# Sum per dimension (typically per variable)
MarginSums <- function(x, MARGIN = 1) {
	y <- apply(x, MARGIN, sum)
	return(y)
}

# Calculate weighted cell means per variable across multiple 
# datasets (`x` as 3-dim matrix)
# Dimension 1 = variable rows
# Dimension 2 = values per group
# Dimension 3 = Different datasets
#
# In the case of a `tableGrepNum` object as a matrix ("splitTableListMatrix")
# Dim 1 = variable rows
# Dim 2 = different patterns: thus different numbers within single cell
# Dim 3 = Different columns of original table (different study groups)
# 
# If `w` is `"firstRow"` it assumes that the first row includes
# number of subjects within each dataset
# which will be used to calculate the weights)
weighted.cellMeans <- function(x, fillN = NULL, name = "",
		w = "firstRow", na.rm = FALSE,...){
	# If only one column, just return x 
	# without N row if w="firstRow"
	if(length(dim(x)) == 2) {
		if(w == "firstRow") {
			return(x[-1,])
		} else {
			return(x)
		}
	} else { 
		if(w == "firstRow") {
			w <- ntoweights(x[1,,], fillN = fillN, name = name, ...)
			x <- x[-1,,]
		}
		y <- apply(x, 1, weightedMarginMeans, w)
		y <- aperm(y, c(2,1))
		return(y)
	} 
}

weighted.cellSums <- function(x, na.rm = FALSE, w = "firstRow", ...){
	if(length(dim(x)) == 2) {
		if(w == "firstRow") {
			x <- x[-1,]
		} 
		return(x)
	} else {
		if(w == "firstRow") {
			x <- x[-1,,]
		} 
		y <- apply(x, 1, MarginSums)
		y <- aperm(y, c(2,1))
		return(y)
	}
}

weightTable <- function(x, types, w = "firstRow", ...){
	n <- NULL
	colName <- colnames(x)
	values <- valueTypes()

	# Creat N values and row values
	if(w == "firstRow") {	
		if(length(dim(x)) == 2) {
			n <- ntoweights(x[1,], returnN = "sum", dimx = 1, ...)
			rowname <- rownames(x)
		} else {
			n <- ntoweights(x[1,,], returnN = "sum", ...)
			rowname <- rownames(x[,,1])	
		}
		types <- types[-1,colName]
	}
	
	Means <- as.data.frame(weighted.cellMeans(x, w = w,...))
	Sums <- as.data.frame(weighted.cellSums(x, w = w,...))
		
	# Mean or Sum
	f <- function(x, values) return(values[x,]$aggregateFUN)
	mors <- apply(types, MARGIN = 2, FUN = f, values = values)=="sum"
	
	# For values were aggregateFUN = "sum" replace mean with sum
	Means[!is.na(mors)&mors] <- Sums[!is.na(mors)&mors] 
	
	# Bind n with NAs to have only a value for pattern1
	n <- c(n, rep(NA, dim(Means)[2] - 1))
	Means <- rbind(n, Means)
	# rownames(Means) <- rowname
	return(Means)	
}


fillN <- missingN

i <- 3
name <- names(mynumeric)[i]
x <- mynumeric[[i]]
types <- dFormat[[i]]

weightTable(x, types, fillN = missingN, name = names(mynumeric)[i])
weightTable(x, types)


	
eval(parse(text="2 + 2"))

weightTables <- function(x, fillN = NULL, types = NULL, ...) {
	if(class(x)== "tableList") {
		if (is.null(types)) {
			types <- getDefaultTypes(myfiles)
		}
		x <- tableGrepNum(myfiles, asMatrx=TRUE)
	} else if (class(x)!= "splitTableListMatrix") {
		stop('x must be an object generated by tableGrepNum() or a tableList')
	}
	name <- names(x)

	y <- mapply(weightTable, x = x, types = types, name = name, 
		MoreArgs=list(fillN = fillN), SIMPLIFY=FALSE)
	class(y) <- "wtdTables"
	return(y)
}

# Function to use the evaluate string from the TypeList object
formatRow <- function(p1,p2,p3,p4,type) {
	return(eval(parse(text=type)))
}

# Apply evaluate string from the Typelist object to table
formatTable <- function(x, type) {
	dig <- options()$digits
	options(digits = 1)	
	p1 <- x$pattern1
	p2 <- x$pattern2
	p3 <- x$pattern3
	p4 <- x$pattern4
	# For rounding purposes
	type <- sub("p1","round(p1,1)", type)
	type <- sub("p2","round(p2,1)", type)
	type <- sub("p3","round(p3,1)", type)
	type <- sub("p4","round(p4,1)", type)
	y <- mapply(formatRow,p1,p2,p3,p4,type)
	y1 <- cbind(x,y)
	#as.data.frame(y)
	#names(y) <- rownames(x)
	options(digits = dig)
	return(y1)
}


formatTables <- function(x, type) {
	if (class(x)!= "wtdTables") {
		stop('x must be an object generated by weightTables()')
	}
	if (class(type)!= "TypeList") {
		stop('type must be a Typelist generated by getDefaultTypes()')
	}
	typelist <- sapply(type,"[[","formatFUN")
	mapply(formatTable, x, typelist, SIMPLIFY=FALSE)
}

formatTables(mywtdtables, dFormat)

x <- mywtdtables[[1]]
typelist <- sapply(dFormat,"[[","formatFUN")
type <- typelist

type1 <- type[1]
x1 <- x[1,]
p4 <- NA



sub("p1","round(p1,1)", type1)

formatRow(x1,type1)
with(x, eval(parse(text=type)))
with(x, parse(text=type))



mapply(formatRow, x, type)








